前回の演習では、Azure Cosmos DB データベース内のブックマークを検索するシナリオを実装しました。 このブックマークのコレクションからデータを読み取ることができるように入力バインディングを構成しました。 しかし、データを読み取るだけではつまらないので、もっと他のこともやってみましょう。 書き込みも行うシナリオに拡張しましょう。 次のフローチャートについて考えてみましょう。

![この Cosmos DB バックエンドにブックマークを追加するプロセスを示すフロー図](../media-draft/add-bookmark-flow-small.png)

このシナリオでは、リストへのブックマークの追加を求める要求を受信します。 この要求によって目的のキーまたは ID が、ブックマーク URL と共に渡されます。 フロー チャート内で確認できるように、そのキーがバックエンド内に既に存在する場合はエラーで応答します。

渡されたキーが*見つからない*場合は、新しいブックマークをデータベースに追加します。 それで終わりにしてもかまいませんが、もう少しやってみましょう。

フローチャート内の別の手順に気付きましたか。 これまで、処理の観点から受信したデータに対して大したことは行っていません。 受信した内容をデータベースに移動します。 ただし、実際のソリューションでは、おそらくそのデータを何らかの方法で処理することが可能です。 同じ関数ですべての処理を実行することもできますが、このラボでは、追加の処理を別のコンポーネントまたはビジネス ロジックの一部にオフロードするパターンを示します。

このブックマーク シナリオでのこの作業のオフロードの良い例として、どのようなことが考えられるでしょうか。 では、新しいブックマークを QR コード生成サービスに送信するというのはどうでしょうか。 そのサービスの場合は、さらに、URL の QR コードが生成され、イメージが BLOB ストレージに格納され、qr イメージのアドレスがブックマーク コレクション内のエントリに再び追加されます。 qr イメージを生成するサービスの呼び出しには時間がかかります。そのため、結果を待つのでなく、関数にサービスを渡して、その関数で非同期的に対処するようにします。

Azure Functions では、さまざまな統合ソースに対して入力バインディングがサポートされているのと同様に、出力バインディング用のテンプレートのセットも用意されています。そのため、お客様はデータ ソースへのデータの書き込みを容易に行うことができます。 出力バインディングはまた、*function.json* ファイルでも構成されています。  この演習で示すように、複数のデータ ソースおよびサービスを操作するように関数を構成できます。


> [!IMPORTANT]
> この演習は、前回のユニットでの演習を基に作成されています、具体的には、前回と同じ Azure Cosmos DB データベースと入力バインディングが使用されます。 そのユニットを終えていない場合は、それを行ってからこのラボに進むことをお勧めします。

## <a name="create-an-httptriggered-function"></a>HTTP によってトリガーされる関数を作成する

1. このモジュールで使用したのと同じ Azure アカウントによって Azure portal ([https://portal.azure.com](https://portal.azure.com?azure-portal=true)) にサインインしていることを確認します。

2. Azure portal で、このモジュールで作成した関数アプリに移動します。

3. ご利用の関数アプリを展開し、関数のコレクションをポイントし、**[関数]** の横にある [追加] (**+**) ボタンを選択します。 この操作により関数作成プロセスが開始されます。 次のアニメーションで、この操作を示します。

![ユーザーが [関数] メニュー項目をポイントしたときにプラス記号が表示されるというアニメーション。](../media-draft/func-app-plus-hover-small.gif)

4. ページのサポートされているトリガーの現在のセットが表示されます。 **[HTTP トリガー]** (次のスクリーン ショットの最初のエントリ) を選択します。

![トリガー テンプレートの選択 UI の一部を示すスクリーン ショット。イメージの左上に TTP トリガーが最初に表示されている。](../media-draft/trigger-templates-small.PNG)

5. 右側に表示された **[新しい関数]** ダイアログに、次の値を使用して入力します。

|フィールド  |値  |
|---------|---------|
|言語     | **JavaScript**        |
|名前     |   [!INCLUDE [func-name-add](./func-name-add.md)]     |
| 承認レベル | **関数** |

5. **[作成]** を選択して関数を作成します。これにより、コード エディターで index.js ファイルが開き、HTTP によってトリガーされる関数の既定の実装が表示されます。

この演習では、出発点で前回のユニットからの*コード*および*構成*を使用することによりスピードアップを図ります。

6. index.js 内のすべてのコードを次のスニペットからのコードに置換します。**[保存]** をクリックして、この変更を保存します。 

[!code-javascript[](../code/find-bookmark-single.js)]

このコードに馴染みがある場合、それはご提供している [!INCLUDE [func-name-find](./func-name-find.md)] 関数の実装だからです。 予想されるとおり、同じバインディングが定義されるまで、関数は機能しません。  

7. [!INCLUDE [func-name-find](./func-name-find.md)] 関数から *function.json* ファイルを開きます。 そのファイルを見つけるには、コード エディターの右側にある **[ファイルの表示]** メニューを開きます。

8. このファイルの内容全体をコピーします。

9. [!INCLUDE [func-name-add](./func-name-add.md)] 関数から *function.json* ファイルを開きます。

10. このファイルの内容を、[!INCLUDE [func-name-find](./func-name-find.md)] 関数に関連付けられた *function.json* ファイルからコピーした内容に置換します。 完了したら、ご自分の function.json に次の JSON が含まれている必要があります。

```json
{
  "bindings": [
    {
      "authLevel": "function",
      "type": "httpTrigger",
      "direction": "in",
      "name": "req"
    },
    {
      "type": "http",
      "direction": "out",
      "name": "res"
    },
    {
      "type": "documentDB",
      "name": "bookmark",
      "databaseName": "func-io-learn-db",
      "collectionName": "Bookmarks",
      "connection": "unit3test_DOCUMENTDB",
      "direction": "in",
      "id": "{id}"
    }
  ],
  "disabled": false
}
```

11. 必ず **[保存]** を選択してすべての変更を保存します。

前の手順では、新しい関数のバインディングを、別の関数からバインディング定義をコピーすることによって構成しました。 もちろん、UI を介して新しいバインディングを作成することもできました。しかし、上記の方法をご利用いただけるということを理解することが重要です。

## <a name="try-it-out"></a>試してみる

1. 通常は、右上の **[</> 関数の URL の取得]** をクリックし、**[既定値 (関数キー)]** を選択して、**[コピー]** をクリックすることで、関数の URL をコピーします。

2. コピーした関数 URL をご利用のブラウザーのアドレス バーに貼り付けます。 この URL の末尾にクエリ文字列 `&id=docs` を追加し、キーボードで `Enter` キーを押して要求を実行します。 すべて順調であれば、そのリソースへの URL を含む応答が表示されます。

さて、どこまできたでしょうか。 これまで、実際には前回のラボで作成した内容をレプリケートしただけでした。 しかし、それは問題ありません。 前回のラボでの処理内容をコピーして、このラボの出発点として活用します。 次に新しい機能を操作します。具体的には、データベースへの書き込みです。 そのため、*出力バインディング*が必要です。

## <a name="define-azure-cosmos-db-output-binding"></a>Azure Cosmos DB の出力バインディングを定義する

ユーザー インターフェイスを経由して新しい出力バインディングを定義するのでなく、構成ファイル *function.json* を手動で更新してこのバインディングを作成します。 

1. エディター内でこの関数用の **function.json** ファイルを開くには **[ファイルの表示]** リストでそれを選択します。

2. `bookmark` という名前のバインディングをそのファイルにコピーします。

3. 閉じ中かっこのすぐ後、閉じ角かっこの直前にカーソルを置きます。 コンマ `,` を追加し、バインディングのコピーをここに貼り付けます。 ご利用の *function.json* 構成ファイルは次のようになります。

[!code-json[](../code/config-new-entry.json?highlight=22-31)]

4. 貼り付けたバインディングを編集して、次の変更を加えます。


|プロパティ   |古い値  |新しい値  |
|---------|---------|---------|
|name     |   bookmark      |  **newbookmark**       |
|direction     |   in      |   **out**      |
|id     |      {id}   |   **このプロパティを削除します。それは出力バインディングには存在しません。**      |

そのような変更を行った場合、次の JSON のようなファイルができあがります。

[!code-json[](../code/config-q-complete.json?highlight=22-30)]

それは、どうすれば構成ファイルでもバインディングを直接作成することができるかを示すデモにすぎませんでした。 この例では、別のバインディングからのプロパティを再利用しているので、それは理にかなっています。具体的には、Cosmos DB 入力バインディング用に既に構成してある `databaseName`、`collectionName`、および `connection` です。

> [!NOTE]
> 上記の JSON ファイル内の `connection` の実際の値は、その接続が作成されたときそれに付けられた任意の名前となります。

コードを更新する前に、キューにメッセージを投稿できるようにするもう 1 つのバインディングを追加してみましょう。

## <a name="define-azure-queue-storage-output-binding"></a>Azure Queue Storage 出力バインディングを定義する

Azure Queue Storage は、世界中のどこからでもアクセスできるメッセージを格納するためのサービスです。 1 つのメッセージの最大サイズは 64 KB です。1 つのキューには、ストレージ アカウントの合計容量の上限に達するまで、数百万のメッセージを格納できます。合計容量の合計はストレージ アカウントで定義されています。 次の図に、このシナリオでのキューの使用方法の概要を示します。

![ストレージ キューの概念と、キューにメッセージをプッシュおよびポップする 2 つの関数を示す図。](../media-draft/q-logical-small.png)

ここで、新しい関数 [!INCLUDE [func-name-add](./func-name-add.md)] によってキューにメッセージが追加されることを確認できます。 別の関数 (例えば、*gen-qr-code* と呼ばれる架空関数) では、同じキューからメッセージがポップされ、要求が処理されます。  [!INCLUDE [func-name-add](./func-name-add.md)] からメッセージをキューに書き込みまたは*プッシュ*するので、このソリューションに新しい出力バインディングを追加します。 今度は UI を通してバインディングを作成してみましょう。

1. 左側にある関数メニューで **[統合]** を選択して、[統合] タブを開きます。

2. **[出力]** 列で **[+ 新しい出力]** を選択します。 使用可能なすべての種類の出力バインディングが一覧表示されます。

3. リストから **[Azure Queue Storage]** をクリックし、**[選択]** ボタンをクリックします。 この操作によって、Azure Queue Storage 出力構成ページが開きます。

次に、ストレージ アカウント接続を設定します。 これはキューがホストされる場所です。

4. このページの **[ストレージ アカウント接続]** という名前のフィールドで、空のフィールドの右側にある *[新規]* をクリックします。 この操作により、**[ストレージ アカウント]** 選択ダイアログが開きます。 

5. このモジュールを開始して関数アプリを作成したとき、ストレージ アカウントも同時に作成されました。 そのストレージ アカウントはこのダイアログに表示されるので、先に進んでそれを選択します。 **[ストレージ アカウント接続]** フィールドには、接続の名前が表示されます。 接続文字列の値を表示したい場合は、**[値の表示]** をクリックします。

6. このページ上の他のフィールドはすべて既定値のままとしておくことができますが、プロパティに意味を加えるために次のように変更してみましょう。


|プロパティ  |古い値  |新しい値  | 説明 |
|---------|---------|---------|---------|
|キュー名     |    outqueue     |  **bookmarks-post-process**      | これは、使用しているキューの中で、ブックマークを別の関数でも処理できるようにブックマークの配置先とするキューの名前です。 |
| メッセージ パラメーター名    |  outputQueueItem       |   **newmessage**      | これはコードで使用するバインディング プロパティです。 |


7. **[保存]** をクリックして変更を保存することを忘れないでください。

## <a name="update-function-implementation"></a>関数の実装を更新する

これで、[!INCLUDE [func-name-add](./func-name-add.md)] 関数に対するバインディングがすべて設定されました。 設定したバインディングをこの関数で使ってみましょう。

1.  関数 [!INCLUDE [func-name-add](./func-name-add.md)] をクリックして、*index.js* をコード エディターで開きます。

2. index.js 内のすべてのコードを次のスニペットのコードに置換します。

[!code-javascript[](../code/add-bookmark.js)]

このコードで何が行われるのかを分析してみましょう。

* この関数によってデータが変更されるので、HTTP 要求が POST になり、ブックマーク データが要求本文の一部になると想定しています。
* Cosmos DB の入力バインディングでは、受信している `id` を使用してドキュメントまたはブックマークの取得が試みられます。 エントリが見つかると、`bookmark` オブジェクトが設定されます。 `if(bookmark)` 条件では、エントリが見つかったかどうかが確認されます。
* データベースへの追加は、`context.bindings.newbookmark` バインディング パラメーターを、JSON 文字列として作成した新しいブックマーク エントリに設定するだけで、簡単に行えます。
* キューへのメッセージの投稿は、`context.bindings.newmessage parameter` を設定するだけで簡単に行えます。

> [!NOTE]
> 行ったタスクは、キュー バインディングを作成することだけでした。 キューの作成は明示的に行っていません。 バインディングの機能をご確認ください。 次のコールアウトで示すように、キューは存在しない場合、自動的に作成されます。

![キューが自動的に作成されることを示すコールアウトのスクリーンショット。](../media-draft/q-auto-create-small.png)

これで終了です。次のセクションで作業内容の動作を確認してみましょう。

## <a name="try-it-out"></a>試してみる

出力バインディングが複数あるので、テストはやや複雑になります。 前のラボでは HTTP 要求とクエリ文字列を送信してテストを行っても問題なかったので、今度は HTTP Post を実行することにします。 また、メッセージがキューに入っているかどうかを確認する必要があります。

1.  Function Apps ポータルで関数 [!INCLUDE [func-name-add](./func-name-add.md)] が選択された状態で、左端にある [テスト] メニュー項目をクリックして関数を展開します。

2. **[テスト]** メニュー項目を選択し、テスト パネルが開いていることを確認します。 次のスクリーンショットでテスト パネルがどのように表示されるかを示します。 

![展開された関数のテスト パネルを示すスクリーン ショット](../media-draft/test-panel-open-small.png)

> [!IMPORTANT]
> HTTP メソッドのドロップダウンで、**[POST]** が選択されていることを確認します。

3. 要求本文の内容を次の JSON ペイロードに置換します。

```json
  {
      "id": "docs",
      "url": "https://docs.microsoft.com/azure"
  }
  ```

4. テスト パネルの下部にある **[実行]** をクリックします。 

5. *[出力]* ウィンドウに、次の図に示すような "ブックマークは既に存在します"  というメッセージが表示されていることを確認します。 

![テスト パネルと失敗したテストの結果を示すスクリーン ショット。](../media-draft/test-exists-small.png)

6. ここで、要求本文を次のペイロードに置き換えます。 

```json
  {
      "id": "github",
      "URL": "https://www.github.com"
  }
  ```
7. テスト パネルの下部にある **[実行]** をクリックします。

8. *[出力]* ボックスに、次の図に示すような "ブックマークが追加されました" というメッセージが表示されていることを確認します。

![テスト パネルと成功したテストの結果を示すスクリーン ショット。](../media-draft/test-success-small.png)

お疲れさまでした。 [!INCLUDE [func-name-add](./func-name-add.md)] は設計どおりに機能しますが、コード内に含めたクエリ動作についてはどうでしょうか。 キューに何か書き込まれたかどうかを確認してみましょう。

### <a name="verify-that-a-message-is-written-to-our-queue"></a>キューにメッセージが書き込まれたことを確認する

Azure Queue Storage キューは、ストレージ アカウントでホストされています。 この演習では、出力バインディングの作成時に既にストレージ アカウントを選択しています。 

1. Azure portal 内のメインの検索ボックスに、「*ストレージ アカウント*」と入力し、検索結果で **[サービス]** カテゴリの下にある *[ストレージ アカウント]* を選択します。 次のスクリーンショットにこれを示します。 

![メインの検索ボックスでの「ストレージ アカウント」に対する検索結果を示すスクリーンショット。](../media-draft/search-for-sa-small.png)

2. 返されたストレージ アカウントのリスト内で、**newmessage** 出力バインディングを作成するために使用したストレージ アカウントを選択します。 ストレージ アカウントの設定はポータルのメイン ウィンドウに表示されます。

3. サービス リストから **[キュー]** 項目を選択します。 これによって、このストレージ アカウントでホストされているキューの一覧が表示されます。 次のスクリーン ショットに示すように、**bookmarks-post-process** キューが存在することを確認します。

![このストレージ アカウントでホストされているキューのリストに、キューが表示されていることを示すスクリーン ショット](../media-draft/q-in-list-small.png)

4. **[bookmarks-post-process]** をクリックしてキューを開きます。 キュー内にあるメッセージがリストに表示されます。 すべてが計画どおりに進んでいれば、ブックマークをデータベースに追加したときに投稿したメッセージは、キュー内に存在するはずであり、次のエントリのようになります。 

![キュー内のメッセージを示すスクリーン ショット](../media-draft/message-in-q-small.png)

この例では、メッセージに一意の ID が付与されており、**MESSAGE TEXT** フィールドに、使用しているブックマークが JSON 文字列の形式で表示されていることを確認できます。

5. 関数はさらにテストすることができます。それには、テスト パネル内で、新しい id/url を設定することで要求本文を変更し、関数を実行します。 このキューを見ると、さらなるメッセージが届いているのがわかります。 また、データベースを参照することで、新しいエントリが追加されていることを確認できます。 

このラボでは、バインディングに関する知識を出力バインディング (Azure Cosmos DB へのデータの書き込み) にまで広げました。 さらに先に進めて、Azure キューにメッセージを投稿するための別の出力バインディングを追加しました。 これにより、データを成形してそれを受信ソースからさまざまな宛先に移動するのに役立つバインディングの真のパワーが実証されました。 データベース コードの作成は行いませんでした。また、接続文字列の管理を自分たちで行う必要もありませんでした。 代わりに、バインディングを宣言によって構成し、接続のセキュリティ保護、関数のスケーリング、および接続のスケーリングをプラットフォームで対処しました。