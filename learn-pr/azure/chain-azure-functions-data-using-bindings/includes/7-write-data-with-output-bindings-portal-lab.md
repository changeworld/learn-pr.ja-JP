前回の演習では、Azure Cosmos DB データベース内のブックマークを検索するシナリオを実装しました。 このブックマークのコレクションからデータを読み取るように入力バインディングを構成しました。 しかし、できることはもっとたくさんあります。 シナリオを拡張して書き込みも行ってみましょう。 次のフローチャートについて考えてみます。

![Cosmos DB バックエンドでブックマークを見つけるプロセスを示すフロー図。 Azure 関数は、ブックマーク ID の要求を受信すると、エラー応答が生成されない場合、要求が有効かどうかを最初にチェックします。 有効な要求の場合、関数はブックマーク ID が Cosmos DB に存在するかどうかチェックし、存在しない場合はエラー応答が生成されます。 ブックマーク ID が見つかると、正常な応答が生成されます。](../media/7-add-bookmark-flow-small.png)

このシナリオでは、コレクションにブックマークを追加する要求を受信します。 この要求によって目的のキーまたは ID が、ブックマーク URL と共に渡されます。 フローチャート内で確認できるように、そのキーがバックエンド内に既に存在する場合はエラーで応答します。

渡されたキーが*見つからない*場合は、新しいブックマークをデータベースに追加します。 それで終わりにしてもかまいませんが、もう少しやってみましょう。

フローチャート内の別の手順に気付きましたか。 これまで、処理の観点から受信したデータに対して大したことは行っていません。 受信した内容をデータベースに移動します。 ただし、実際のソリューションでは、おそらくそのデータを何らかの方法で処理することが可能です。 同じ関数ですべての処理を実行することもできますが、このラボでは、追加の処理を別のコンポーネントまたはビジネス ロジックの一部にオフロードするパターンを示します。

このブックマーク シナリオでのこの作業のオフロードの良い例として、どのようなものが考えられるでしょうか。 新しいブックマークを QR コード生成サービスに送信するというのはどうでしょう。 そのサービスの場合は、さらに、URL の QR コードが生成され、イメージが BLOB ストレージに格納され、QR イメージのアドレスがブックマーク コレクション内のエントリに再び追加されます。 QR イメージを生成するサービスの呼び出しには時間がかかります。そのため、結果を待つのでなく、関数にサービスを渡して、その関数で非同期的に対処するようにします。

Azure Functions では、さまざまな統合ソースに対して入力バインディングがサポートされているのと同様に、出力バインディング用のテンプレートのセットも用意されています。そのため、お客様はデータ ソースへのデータの書き込みを容易に行うことができます。 出力バインディングは、*function.json* ファイルでも構成されています。  この演習で示すように、複数のデータ ソースとサービスを操作するように関数を構成できます。

> [!IMPORTANT]
> この演習は前の演習に基づいています。 同じ Azure Cosmos DB データベースと入力バインディングが使用されています。 そのユニットを終えていない場合は、それを行ってからこのユニットに進むことをお勧めします。

## <a name="create-an-http-triggered-function"></a>HTTP によってトリガーされる関数を作成する

1. サンドボックスをアクティブ化したときと同じアカウントを使用して、[Azure portal](https://portal.azure.com/learn.docs.microsoft.com?azure-portal=true) にサインインします。

2. ポータルで、このモジュールで作成した関数アプリに移動します。

3. ご利用の関数アプリを展開し、関数のコレクションをポイントして、**[関数]** の横にある [追加] (**+**) ボタンを選択します。 この操作により関数作成プロセスが開始されます。 次のアニメーションで、この操作を示します。

    ![ユーザーが [関数] メニュー項目をポイントしたときにプラス記号が表示されるというアニメーション。](../media/3-func-app-plus-hover-small.gif)

4. ページのサポートされているトリガーの現在のセットが表示されます。 **[HTTP トリガー]** (次のスクリーン ショットの最初のエントリ) を選択します。

    ![トリガー テンプレートの選択 UI の一部を示すスクリーンショット。イメージの左上に TTP トリガーが最初に表示されている。](../media/5-trigger-templates-small.PNG)


5. 右側に表示された **[新しい関数]** ウィンドウに、次の値を使用して入力します。

    |フィールド  |値  |
    |---------|---------|
    |言語     | **JavaScript**        |
    |名前     |   [!INCLUDE [func-name-add](./func-name-add.md)]     |
    | 承認レベル | **関数** |

6. **[作成]** を選択して関数を作成します。 これにより、コード エディターで **index.js** ファイルが開き、HTTP によってトリガーされる関数の既定の実装が表示されます。

    > [!NOTE]
    > この演習では、出発点として前のユニットからの*コード*および*構成*を使用することによりスピードアップを図ります。

7. **index.js** ファイル内のすべてのコードを、次のスニペットのコードに置き換え、**[保存]** を選択して変更を保存します。

   [!code-javascript[](../code/find-bookmark-single.js)]

   このコードをよくご存じの場合、それは提供されている [!INCLUDE [func-name-find](./func-name-find.md)] 関数の実装だからです。 予想されるとおり、同じバインディングが定義されるまで、関数は機能しません。

1. [!INCLUDE [func-name-add](./func-name-add.md)] 関数から **function.json** ファイルを開きます。

11. このファイルの内容を次の JSON に置き換えます。

    ```json
    {
      "bindings": [
        {
          "authLevel": "function",
          "type": "httpTrigger",
          "direction": "in",
          "name": "req"
        },
        {
          "type": "http",
          "direction": "out",
          "name": "res"
        },
        {
          "type": "documentDB",
          "name": "bookmark",
          "databaseName": "func-io-learn-db",
          "collectionName": "Bookmarks",
          "connection": "unit3test_DOCUMENTDB",
          "direction": "in",
          "id": "{id}"
        }
      ],
      "disabled": false
    }
    ```

12. 必ず、すべての変更を**保存**してください。

前の手順では、新しい関数のバインディングを、別の関数からバインディング定義をコピーすることによって構成しました。 もちろん、UI を介して新しいバインディングを作成することもできましたが、この代替方法を利用できることを理解しておくことはよいことです。

## <a name="try-it-out"></a>試してみる

1. 右上の **[関数の URL の取得]**、**[既定値 (関数キー)]**、**[コピー]** の順に選択して関数の URL をコピーします。

2. コピーした URL をブラウザーのアドレス バーに貼り付けます。 URL の末尾にクエリ文字列値 `&id=docs` を追加してから、Enter キーを押して要求を実行します。 すべて順調であれば、そのリソースへの URL を含む応答が表示されます。

さて、どこまで来たでしょうか。 これまで、実際には前回のラボで行った内容をレプリケートしただけでした。 しかし、それは問題ありません。 前回のラボで行った内容をコピーして、このラボの出発点として活用します。 次は新しい機能を操作します。 つまり、データベースに書き込みます。 そのため、*出力バインディング*が必要です。

## <a name="define-azure-cosmos-db-output-binding"></a>Azure Cosmos DB の出力バインディングを定義する

ユーザー インターフェイスを経由して新しい出力バインディングを定義するのでなく、構成ファイル *function.json* を手動で更新してこのバインディングを作成します。

1. エディターで [!INCLUDE [func-name-add](./func-name-add.md)] の *function.json* ファイルを開いていることを確認してください。

1. そのファイルの `bookmark` という名前のバインディングをコピーします。

1. 閉じ中かっこ (}) のすぐ後、閉じ角かっこ (]) のすぐ前にカーソルを置きます。 コンマ (,) を追加し、バインディングのコピーをここに貼り付けます。 ご利用の *function.json* 構成ファイルは次のようになります。

   [!code-json[](../code/config-new-entry.json?highlight=22-31)]

1. 貼り付けたバインディングを編集して、次の変更を加えます。

    |プロパティ   |古い値  |新しい値  |
    |---------|---------|---------|
    |name     |   bookmark      |  **newbookmark**       |
    |direction     |   in      |   **out**      |
    |id     |      {id}   |   **このプロパティを削除します。それは出力バインディングには存在しません。**      |

1. これらの変更を行った後、ファイルは次の JSON のようになります。

    [!code-json[](../code/config-q-complete.json?highlight=22-30)]

これは、どのようにすれば構成ファイルでもバインディングを直接作成できるかを示すデモにすぎません。 この例では、別のバインディングからのプロパティを再利用するので、それは理にかなっています。 つまり、Cosmos DB 入力バインディング用に既に構成してある `databaseName`、`collectionName`、および `connection` を再利用します。

> [!NOTE]
> 上記の JSON ファイル内の `connection` の実際の値は、接続が作成されたときにそれに付けられた任意の名前です。

コードを更新する前に、キューにメッセージを投稿できるようにバインディングをもう 1 つ追加してみましょう。

## <a name="define-azure-queue-storage-output-binding"></a>Azure Queue Storage 出力バインディングを定義する

Azure Queue Storage は、世界中のどこからでもアクセスできるメッセージを格納するためのサービスです。 単一のメッセージのサイズは 64 KB ほどになります。キューには、ストレージ アカウントの合計容量に達するまで、数百万のメッセージを格納できます。この合計容量はストレージ アカウントで定義されています。 次の図に、このシナリオでのキューの使用方法の概要を示します。

![ストレージ キューと 2 つの関数 (1 つはキューにメッセージをプッシュし、もう 1 つはキューにメッセージをポップする) を示す図。](../media/7-q-logical-small.png)

ここで、新しい関数 [!INCLUDE [func-name-add](./func-name-add.md)] によってキューにメッセージが追加されることを確認できます。 別の関数 (例えば、*gen-qr-code* と呼ばれる架空の関数) では、同じキューからメッセージがポップされ、要求が処理されます。  [!INCLUDE [func-name-add](./func-name-add.md)] からキューにメッセージを書き込む (つまり、*プッシュする*) ので、このソリューションに新しい出力バインディングを追加します。 今度は、ポータル UI を介してバインディングを作成してみましょう。

1. 左側の関数メニューで **[統合]** を選択して、[統合] タブを開きます。

2. **[出力]** 列で **[新しい出力]** を選択します。
    使用可能なすべての種類の出力バインディングのリストが表示されます。

3. このリストで、**[Azure Queue Storage]**、**[選択]** の順に選択します。
    この操作によって、Azure Queue Storage 出力構成ページが開きます。

   次に、ストレージ アカウント接続を設定します。 これはキューがホストされる場所です。

4. **[ストレージ アカウント接続]** フィールドの右側にある **[新規]** を選択します。
   **ストレージ アカウント**の選択ウィンドウが開きます。

5. このモジュールを開始して関数アプリを作成したとき、ストレージ アカウントも同時に作成されました。 このウィンドウにリストされますので、それを選択してください。 **[ストレージ アカウント接続]** フィールドには、接続の名前が設定されます。 接続文字列の値を表示する場合は、**[値の表示]** を選択します。

6. 他のフィールドはすべて既定値のままにしておいてもかまいませんが、ここではプロパティに意味を加えるために次のように変更します。

    |プロパティ  |古い値  |新しい値  | 説明 |
    |---------|---------|---------|---------|
    |キュー名     |    outqueue     |  **bookmarks-post-process**      | ブックマークを別の関数でさらに処理できるようにブックマークの配置先とするキューの名前です。 |
    | メッセージ パラメーター名    |  outputQueueItem       |   **newmessage**      | コードで使用するバインディング プロパティです。 |

7. **[保存]** を選択して変更を保存することを忘れないでください。

## <a name="update-function-implementation"></a>関数の実装を更新する

これで、[!INCLUDE [func-name-add](./func-name-add.md)] 関数に対するバインディングがすべて設定されました。 それらをこの関数で使ってみましょう。

1.  関数 [!INCLUDE [func-name-add](./func-name-add.md)] を選択して、**index.js** ファイルをコード エディターで開きます。

2. *index.js* ファイル内のすべてのコードを、次のスニペットのコードに置き換えます。

   [!code-javascript[](../code/add-bookmark.js)]

このコードで何が行われるのかを詳しく見てみましょう。

* この関数によってデータが変更されるので、HTTP 要求が POST になり、ブックマーク データが要求本文の一部になると想定しています。
* Azure Cosmos DB の入力バインディングでは、受信する `id` を使用してドキュメントまたはブックマークの取得が試みられます。 エントリが見つかると、`bookmark` オブジェクトが設定されます。 `if(bookmark)` 条件では、エントリが見つかったかどうかが確認されます。
* データベースへの追加は、JSON 文字列として作成した新しいブックマーク エントリに `context.bindings.newbookmark` バインディング パラメーターを設定するのと同じくらいシンプルです。
* キューへのメッセージの投稿は、`context.bindings.newmessage parameter` を設定するのと同じくらいシンプルです。

> [!NOTE]
> 行ったタスクは、キュー バインディングの作成のみです。 キューの作成は明示的に行っていません。 バインディングの機能を確認しましょう。 次のコールアウトで示すように、キューは存在しない場合、自動的に作成されます。

![キューが自動的に作成されることを示すコールアウトのスクリーンショット。](../media/7-q-auto-create-small.png)

これで終了です。 次のセクションで作業内容の動作を確認してみましょう。

## <a name="try-it-out"></a>試してみる

出力バインディングが複数あるので、テストはやや複雑になります。 前のラボでは HTTP 要求とクエリ文字列を送信し、テストして満足しましたが、今度は HTTP 投稿を実行する必要があります。 メッセージがキューに入っているかどうかを確認する必要もあります。

1. Function App ポータルで関数 [!INCLUDE [func-name-add](./func-name-add.md)] を選択した状態で、左端にある [テスト] メニュー項目を選択して展開します。

2. **[テスト]** メニュー項目を選択し、テスト パネルが開いていることを確認します。 次のスクリーンショットは、どのような表示になるかを示しています。

    ![展開された関数のテスト パネルを示すスクリーンショット。](../media/7-test-panel-open-small.png)

    > [!IMPORTANT]
    > HTTP メソッドのドロップダウン リストで、**[POST]** が選択されていることを確認します。

3. 要求本文の内容を、次の JSON ペイロードで置き換えます。

    ```json
    {
        "id": "docs",
        "url": "https://docs.microsoft.com/azure"
    }
    ```

4. テスト パネルの下部にある **[実行]** を選択します。

5. **[出力]** ウィンドウに、次の図に示すような "ブックマークは既に存在します" というメッセージが表示されていることを確認します。

    ![テスト パネルと失敗したテストの結果を示すスクリーンショット。](../media/7-test-exists-small.png)

6. 要求本文を次のペイロードに置き換えます。

    ```json
    {
        "id": "github",
        "url": "https://www.github.com"
    }
    ```
7. テスト パネルの下部にある **[実行]** を選択します。

8. *[出力]* ボックスに、次の図に示すような "ブックマークが追加されました" というメッセージが表示されていることを確認します。

    ![テスト パネルと成功したテストの結果を示すスクリーン ショット。](../media/7-test-success-small.png)

お疲れさまでした。 [!INCLUDE [func-name-add](./func-name-add.md)] は設計どおりに機能しますが、コード内に含めたクエリ操作についてはどうでしょうか。 キューに何か書き込まれたかどうかを確認してみましょう。

### <a name="verify-that-a-message-is-written-to-the-queue"></a>キューにメッセージが書き込まれたことを確認する

Azure Queue Storage キューは、ストレージ アカウントでホストされています。 この演習では、出力バインディングの作成時にストレージ アカウントを既に選択しています。

1. Azure portal 内のメインの検索ボックスに「**ストレージ アカウント**」と入力し、結果リストで **[サービス]** の下にある **[ストレージ アカウント]** を選択します。

      ![メインの検索ボックスでのストレージ アカウントに対する検索結果を示すスクリーンショット。](../media/7-search-for-sa-small.png)

2. 返されたストレージ アカウントのリストで、**newmessage** 出力バインディングを作成するために使用したストレージ アカウントを選択します。
   ストレージ アカウントの設定はポータルのメイン ウィンドウに表示されます。

3. **[サービス]** リストで、**[キュー]** 項目を選択します。
   このストレージ アカウントでホストされているキューのリストが表示されます。 次のスクリーンショットに示すように、**bookmarks-post-process** キューが存在することを確認します。

      ![このストレージ アカウントでホストされているキューのリストにキューが表示されていることを示すスクリーンショット](../media/7-q-in-list-small.png)

4. **[bookmarks-post-process]** を選択してキューを開きます。
   キュー内にあるメッセージがリストに表示されます。 すべてが計画どおりに進んでいれば、ブックマークをデータベースに追加したときに投稿したメッセージがキューに含まれています。 つまり、次のようになります。

    ![キュー内のメッセージを示すスクリーンショット](../media/7-message-in-q-small.png)

   この例では、メッセージに一意の ID が付与されており、**MESSAGE TEXT** フィールドに、使用しているブックマークが JSON 文字列の形式で表示されていることを確認できます。

5. 関数はさらにテストすることができます。それには、テスト ウィンドウ内で、新しい id/url を設定して要求本文を変更し、関数を実行します。 このキューを見ると、さらにメッセージが届いているのがわかります。 また、データベースを参照することで、新しいエントリが追加されていることを確認できます。

このラボでは、バインディングに関する知識を出力バインディング (Azure Cosmos DB へのデータの書き込み) にまで広げました。 さらに先に進んで、Azure キューにメッセージを投稿するための別の出力バインディングを追加しました。 これにより、データを成形してそれを受信ソースからさまざまな宛先に移動するのに役立つバインディングの真のパワーが実証されました。 データベース コードの作成は行いませんでした。また、接続文字列の管理を自分で行う必要もありませんでした。 代わりに、バインディングを宣言によって構成し、接続のセキュリティ保護、関数のスケーリング、および接続のスケーリングをプラットフォームで行いました。