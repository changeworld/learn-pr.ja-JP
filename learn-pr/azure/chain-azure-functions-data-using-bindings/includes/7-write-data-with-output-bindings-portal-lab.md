前回の演習では、Azure Cosmos DB データベース内のブックマークを検索するシナリオを実装しました。 このブックマークのコレクションからデータを読み取る入力バインディングを構成しました。 データを読み取るだけするは面倒ですより行ってみましょう。 書き込み対象のシナリオを拡張しましょう。 次のフローチャートを検討してください。

![バック エンド、Cosmos DB でブックマークを追加するプロセスを示すフロー図](../media-draft/add-bookmark-flow-small.png)

このシナリオで受信要求の一覧にブックマークを追加します。 目的のキーまたは ID、ブックマークの URL と共に、要求を渡します。 フロー チャートでご覧のとおり、バックエンドで、キーが既に存在する場合はエラーで回答いたします。

渡されたキーが場合*いない*が見つかると、新しいブックマークを追加、データベース。 停止しましたが、もう少しやってみましょうでした。

フローチャート内の別の手順に注意してください。 これまでに多くの受信処理の観点からデータを行っていません。 受信データベースに移動します。 ただし、実際のソリューションでは、なんらかの方法でデータを処理しましたはおそらく可能なは。 この演習ではさらに別のコンポーネントまたはビジネス ロジックの一部を処理の負荷を軽減するパターンを紹介しますが、同じ関数内のすべての処理を実行して判断できます。

このブックマーク シナリオでの作業のオフロードの良い例として考えられるのでしょうか。 場合、新しいブックマークに送信 QR コードの生成サービスですか。 そのサービスは、さらに、URL の QR コードを生成、blob ストレージにイメージを格納および qr イメージのアドレスをブックマークのコレクション内のエントリに追加します。 Qr イメージを生成するサービスを呼び出すには時間がかかるためではなく、結果を待つよりも関数に渡すし、その非同期的にこれに対応します。

Azure Functions では、さまざまな統合のソースの入力バインディングをサポートすると同様に、一連のデータをデータ ソースを記述しやすく出力バインドのテンプレートもあります。 出力バインディングは構成ことも、 *function.json*ファイル。  この演習で表示されるよう、複数のデータ ソースとサービスを使用する関数を構成できます。

> [!IMPORTANT]
> この演習を最後の単位の演習をビルド、具体的には、同じ Azure Cosmos DB データベースとの入力バインドを使用します。 その単位を実行していない、この演習に進む前にそうことをお勧めします。

## <a name="create-an-httptriggered-function"></a>HTTP_triggered 関数を作成します。

1. [Azure portal](https://portal.azure.com/?azure-portal=true) にサインインします。

2. Azure portal では、このモジュールで作成した関数アプリに移動します。

3. 関数アプリを展開し、関数のコレクションをポイントし、追加を選択します (**+**) ボタンの横に**関数**します。 このアクションは、関数の作成プロセスを開始します。 次のアニメーションは、この操作を示しています。

![プラス記号が表示される、ユーザーが関数のメニュー項目を置いたときのアニメーション。](../media-draft/func-app-plus-hover-small.gif)

4. ページのサポートされているトリガーの現在のセットが表示されます。 選択**HTTP トリガー**、これは、次のスクリーン ショットの最初のエントリ。

![上で最初に、表示される TTP トリガーでトリガー テンプレートの選択、UI の一部のスクリーン ショットは、イメージの左。](../media-draft/trigger-templates-small.PNG)

5. 記入、**新しい関数**次の値を使用して、右側に表示されるダイアログ ボックス。

|フィールド  |値  |
|---------|---------|
|言語     | **JavaScript**        |
|名前     |   [!INCLUDE [func-name-add](./func-name-add.md)]     |
| 承認レベル | **Function** |

5. 選択**作成**、コード エディターで、index.js ファイルを開き、HTTP によってトリガーされる関数の既定の実装が表示される関数を作成します。

この演習で私たちが速度が上がるものを使用して、*コード*と*構成*開始点としては、前の単位から。

6. Index.js 内のすべてのコードを次のスニペットとクリックからコードに置き換えます**保存**変更を保存します。 

[!code-javascript[](../code/find-bookmark-single.js)]

実装であるいる場合、このコードはよく知っています。、、[!INCLUDE [func-name-find](./func-name-find.md)]関数。 期待どおりには、同じバインディングを定義するまで、関数は機能しません。  

7. 開く、 *function.json*ファイルから、[!INCLUDE [func-name-find](./func-name-find.md)]関数。 開いてわかります、**ファイルを表示**コード エディターの右側にあるメニュー。

8. このファイルの内容全体をコピーします。

9. 開く、 *function.json*ファイルから、[!INCLUDE [func-name-add](./func-name-add.md)]関数。

10. このファイルの内容を置き換えますからコピーしたコンテンツ、 *function.json*に関連付けられているファイル、[!INCLUDE [func-name-find](./func-name-find.md)]関数。 完成したときに、function.json は次の JSON を含める必要があります。

```json
{
  "bindings": [
    {
      "authLevel": "function",
      "type": "httpTrigger",
      "direction": "in",
      "name": "req"
    },
    {
      "type": "http",
      "direction": "out",
      "name": "res"
    },
    {
      "type": "documentDB",
      "name": "bookmark",
      "databaseName": "func-io-learn-db",
      "collectionName": "Bookmarks",
      "connection": "unit3test_DOCUMENTDB",
      "direction": "in",
      "id": "{id}"
    }
  ],
  "disabled": false
}
```

11. 必ず**保存**すべての変更。

前の手順で構成したバインド、新しい関数バインディングの定義をコピーすることによって。 でしたもちろん、UI から新しいバインドの作成がこの方法をご確認いただけることを理解することをお勧めします。

## <a name="try-it-out"></a>試してみる

1. 通常どおり、 をクリックして **<>/Get 関数の URL**右側の上部にある次のように選択します。**既定 (関数キー)**、 をクリックし、**コピー** copy、関数の URL。

2. ブラウザーのアドレス バーにコピーしておいた関数の URL を貼り付けます。 この URL の末尾にクエリ文字列 `&id=docs` を追加し、キーボードで`Enter` キーを押して要求を実行します。 すべて順調だと、そのリソースへの URL を含む応答が表示されます。

そのため、ここでははでしょうか。 これまでに実際にはレプリケートした前の実習で行いました。 しかし、[ok] です。 この 1 つの開始点として機能する最後のラボで実行した内容をコピーすることはできます。 操作を行います。 新しい機能を次に、具体的には、データベースへの書き込み。 そのため、必要があります、*出力バインド*します。

## <a name="define-azure-cosmos-db-output-binding"></a>定義 Azure Cosmos DB 出力バインド

はなく、ユーザー インターフェイスを経由して新しい出力バインドを定義する代わりに作成しますこのバインディング構成ファイルを更新することで*function.json*、手動でします。 

1. 開く、 **function.json**でを選択して、エディターでこの関数のファイル、**ファイルを表示**一覧。

2. 名前のバインドのコピー`bookmark`ファイル。

3. 右中かっこ、閉じ角かっこの直前と直後にカーソルを置きます。 コンマを追加`,`バインドのコピーを貼り付けるとここでします。 *Function.json*構成は次のようになります。

[!code-json[](../code/config-new-entry.json?highlight=22-31)]

4. 以下の変更を貼り付けたバインドを編集します。


|プロパティ   |古い値  |新しい値  |
|---------|---------|---------|
|name     |   ブックマーク      |  **newbookmark**       |
|direction     |   in      |   **アウト**      |
|id     |      {id}   |   **このプロパティを削除します。出力バインディングには存在しません。**      |

これらの変更を行った場合に最終的に次の JSON のようなファイルを使用します。

[!code-json[](../code/config-q-complete.json?highlight=22-30)]

構成ファイルで直接バインドも作成する方法のデモだけでした。 この例では、理にかなってつまり、別のバインドからプロパティを再利用するため、 `databaseName`、`collectionName`と`connection`既に構成されていること、Cosmos DB 入力バインドします。

> [!NOTE]
> 実際の値`connection`で、上記の JSON ファイルは、接続は作成時に指定された任意の名前になります。

コードを更新する前にキューにメッセージを投稿できるように、複数のバインドが 1 つを追加してみましょう。

## <a name="define-azure-queue-storage-output-binding"></a>定義 Azure Queue Storage 出力バインド

Azure Queue storage は、世界中どこからアクセスできるメッセージを格納するサービスです。 1 つのメッセージは、最大 64 KB、キューに数百万のメッセージが定義されているストレージ アカウントの合計容量の上限に達するまで含めることができます。 次の図は高レベルで、このシナリオでのキューの使用方法。

![ストレージ キューの概念とプッシュとポップをキューにメッセージの 2 つの関数を示す図。](../media-draft/q-logical-small.png)

ここで確認できます、新しい関数では、[!INCLUDE [func-name-add](./func-name-add.md)]キューにメッセージを追加します。 架空の関数の例については、別の関数と呼ばれる*qr コードを生成*は、同じキューからメッセージを表示および要求を処理します。  記述または*プッシュ*、メッセージをキューから[!INCLUDE [func-name-add](./func-name-add.md)]ソリューションに新しい出力バインドを追加します。 この時間は UI からバインドを作成してみましょう。

1. 選択**統合**関数 メニューの 統合 タブを開き、左側にします。

2. 選択 **+ 新しい出力**下、**出力**列。 すべての使用可能な出力バインドの種類の一覧が表示されます。

3. をクリックして**Azure Queue Storage**一覧からをクリックし、**選択**ボタンをクリックします。 この操作は、Azure Queue Storage 出力の構成 ページを開きます。

次に、ストレージ アカウント接続を設定します。 これは、キューをホストします。

4. という名前のフィールドで**ストレージ アカウント接続**このページで、クリックして*新しい*空のフィールドの右側にします。 このアクションが表示されます、**ストレージ アカウント**の選択 ダイアログ。 

5. このモジュールを開始して、関数アプリを作成、ストレージ アカウントがその時点でも作成します。 そのため進んでされ、選択、このダイアログ ボックスに表示されます。 **ストレージ アカウント接続**フィールドには、接続の名前が表示されます。 接続文字列の値を表示する場合は、をクリックして**値を表示する**します。

6. このページで、既定値を持つ他のすべてのフィールドは省略できます、プロパティの意味を持たせる貸与することを次のように変更してみましょう。


|プロパティ  |古い値  |新しい値  | 説明 |
|---------|---------|---------|---------|
|キュー名     |    outqueue     |  **ブックマーク後処理**      | これは、名前の配置を使用しているキューのブックマークに処理できるようにしてさらに別の関数。 |
| メッセージ パラメーター名    |  outputQueueItem       |   **newmessage**      | これはバインド プロパティをコードで使用します。 |


7. クリックする**保存**変更を保存します。

## <a name="update-function-implementation"></a>Update 関数の実装

ある用に、バインド設定すべて、[!INCLUDE [func-name-add](./func-name-add.md)]関数。 これらの関数で使用する時間になります。

1.  この関数では、をクリックして[!INCLUDE [func-name-add](./func-name-add.md)]を開くには、 *index.js*コード エディターでします。

2. Index.js 内のすべてのコードを次のスニペットをコードに置き換えます。

[!code-javascript[](../code/add-bookmark.js)]

みましょう内訳は、このコードの内容。

* この関数が、データを変更するため、要求本文の一部にするには、投稿してブックマーク データへの HTTP 要求を予定です。
* ドキュメント、または、ブックマークを取得しようとしている、Cosmos DB 入力バインドを使用して、`id`受信します。 エントリが見つかった場合は、`bookmark`オブジェクトが設定されます。 `if(bookmark)`条件は、エントリが見つかったかどうかを確認します。
* 設定するだけでは、データベースへの追加、 `context.bindings.newbookmark` JSON 文字列として作成した新しいブックマーク エントリのバインディング パラメーター。
* 設定するだけでは、キューにメッセージを投稿、`context.bindings.newmessage parameter`します。

> [!NOTE]
> キュー バインドを作成する唯一のタスクを実行したことでした。 私たち作成されていないキューを明示的にします。 バインドの電源を目撃しようとしてください。 次のコールアウトが言うよう存在しない場合、キューを自動的に作成!

![呼び出すスクリーン ショット、キューが自動で作成されます。](../media-draft/q-auto-create-small.png)

そのため、これで完了です - で、次のセクション内のアクションでの作業を見てみましょう。

## <a name="try-it-out"></a>試してみる

複数の出力バインドしたら、テスト、やや難しくなりますになります。 前の演習で HTTP 要求とクエリ文字列を送信することをテストするコンテンツが、一方、この回の HTTP Post を実行することもします。 また、メッセージ作成か、キューに確認する必要があります。

1.  この関数を使用した[!INCLUDE [func-name-add](./func-name-add.md)]、展開に一番左にあるテスト メニュー項目をクリックして、関数アプリのポータルで選択されている。

2. 選択、**テスト**メニュー項目し、テストのパネルが開いていることを確認します。 次のスクリーン ショット、どのようなようになります。 

![関数のテストのパネルを示すスクリーン ショットが展開されます。](../media-draft/test-panel-open-small.png)

> [!IMPORTANT]
> 確認します**POST** HTTP メソッドのドロップダウン リストで選択されます。

3. 要求本文の内容を次の JSON ペイロードに置き換えます。

```json
  {
      "id": "docs",
      "url": "https://docs.microsoft.com/azure"
  }
  ```

4. クリックして**実行**テスト パネルの下部にあります。 

5. いることを確認、*出力*ウィンドウは、「ブックマーク既に存在します」が表示されます。 次の図に示すようにメッセージ。 

![パネルのテストと失敗したテストの結果を示すスクリーン ショット。](../media-draft/test-exists-small.png)

6. 今すぐ次のペイロードを要求本文を置き換えます。 

```json
  {
      "id": "github",
      "URL": "https://www.github.com"
  }
  ```
7. クリックして**実行**テスト パネルの下部にあります。

8. 確認します*出力*次の図に示すようにボックスに「ブックマークの追加」メッセージが表示されます。

![パネルのテストと成功したテストの結果を示すスクリーン ショット。](../media-draft/test-success-small.png)

お疲れさまでした。 [!INCLUDE [func-name-add](./func-name-add.md)]いたコードは、そのキューの操作については、設計どおりに機能しますか? それでは、「何かキューに書き込まれた場合。

### <a name="verify-that-a-message-is-written-to-our-queue"></a>このキューにメッセージを書き込むことを確認します。

Azure Queue Storage のキューは、ストレージ アカウントでホストされます。 出力バインドを作成するときに既にには、この演習では、ストレージ アカウントを選択します。 

1. Azure portal での主な検索ボックスに「*ストレージ アカウント*検索の結果選択と**ストレージ アカウント**下、*サービス*カテゴリ。 これは、次のスクリーン ショットに示します。 

![メインの検索ボックスでストレージ アカウントの検索結果をスクリーン ショット。](../media-draft/search-for-sa-small.png)

2. 返されるストレージ アカウントの一覧で、選択を作成するために使用するストレージ アカウント、**新しいメッセージ**出力バインドです。 ストレージ アカウントの設定がメイン ウィンドウに表示されるポータル。

3. 選択、**キュー**サービスの一覧から項目。 これには、このストレージ アカウントでホストされているキューの一覧が表示されます。 いることを確認、**ブックマーク後処理**次のスクリーン ショットに示すようにキューが存在します。

![このストレージ アカウントでホストされているキューの一覧で、キューを示すスクリーン ショット](../media-draft/q-in-list-small.png)

4. をクリックして**ブックマーク後処理**キューを開きます。 一覧には、キューにメッセージが表示されます。 計画に従って問題が場合、データベースへのブックマークを追加したときに掲載したメッセージはキューには、エントリを次のようになります。 

![キューにメッセージを示すスクリーン ショット](../media-draft/message-in-q-small.png)

この例で、メッセージの一意の ID が指定されているを参照できます、**メッセージ テキスト**フィールドが JSON 文字列の形式で、ブックマークを表示します。

5. 関数をさらには、新しい id または url セットとテストのパネルで、要求本文を変更して、関数を実行してテストできます。 追加のメッセージの到着を表示するには、このキューをご覧ください。 検索することも確認するデータベースに新しいエントリが追加されました。 

このラボでバインドの知識に拡張出力のバインドを Azure Cosmos DB にデータを書き込みます。 さらに進んでし、Azure キューにメッセージを投稿への別の出力バインドを追加します。 これは、バインドの図形および受信のソースからさまざまな変換先にデータを移動するための真の力を示しています。 任意のデータベースのコードを記述しています。 していないしたり自分たちの接続文字列を管理する必要があります。 バインドを構成する代わりに、宣言によって、プラットフォームの接続のセキュリティ保護、スケーリング、関数、およびスケーリングの接続を処理できるようにします。