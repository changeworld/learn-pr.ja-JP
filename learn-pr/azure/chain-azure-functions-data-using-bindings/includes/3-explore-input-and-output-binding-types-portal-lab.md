この演習で作成するデモの概要図を次に示します。

![HTTP 要求と HTTP 応答、およびそれぞれの req バインディング パラメーターと res バインディング パラメーターを示す、既定の HTTP トリガーの視覚的な表現。](../media-draft/default-http-trigger-visual-small.PNG)

HTTP 要求を受信すると起動し、メッセージを送信することで各要求に応答する関数を作成します。 パラメーター `req` と `res` は、それぞれトリガー バインディングと出力バインディングです。 さあ、始めましょう。

Azure アカウントで Azure portal ([https://portal.azure.com](https://portal.azure.com?azure-portal=true)) にサインインします。

### <a name="create-a-function-app"></a>関数アプリを作成する

このモジュール全体で使用する関数アプリを作成しましょう。 関数アプリを使用すると、リソースの管理、デプロイ、および共有を容易にするための論理ユニットとして関数をグループ化できます。

[!INCLUDE [resource-group-note](./rg-notice.md)]

1. Azure portal の左上隅にある **[リソースの作成]** ボタンを選択し、**[コンピューティング]** > **[Function App]** の順に選択します。
1. 関数アプリのプロパティを次のように設定します。


    | プロパティ      | 推奨値  | 説明                                        |
    | ------------ |  ------- | -------------------------------------------------- |
    | **アプリ名** | グローバルに一意の名前 | 新しい関数アプリを識別する名前。 有効な文字は、`a-z`、`0-9`、および `-` です。  | 
    | **サブスクリプション** | ご利用のサブスクリプション | この新しい関数アプリが作成されるサブスクリプション。 | 
    | **リソース グループ**|  [!INCLUDE [resource-group-name](./rg-name.md)] | 関数アプリを作成するための新しいリソース グループの名前。 | 
    | **OS** | Windows | 関数アプリをホストするオペレーティング システム。  |
    | **ホスティング** |   従量課金プラン | Function App にどのようにリソースが割り当てられるかを定義するホスティング プラン。 既定の **[従量課金プラン]** では、リソースは関数の必要に応じて動的に追加されます。 この[サーバーなしの](https://azure.microsoft.com/overview/serverless-computing/)ホスティングでは、関数が実行された時間にのみ課金されます。   |
    | **場所** | 西ヨーロッパ | ユーザーに近い[リージョン](https://azure.microsoft.com/regions/)、または関数がアクセスする他のサービスの近くのリージョンを選択します。 |
    | **ストレージ アカウント** |  グローバルに一意の名前 |  関数アプリによって使用される新しいストレージ アカウントの名前。 ストレージ アカウント名の長さは 3 - 24 文字で、数字と小文字のみを使用できます。 このダイアログ ボックスでは、アプリに指定した名前から派生した一意の名前がフィールドに入力されます。 ただし、別の名前や既存のアカウントも自由に使用できます。 |


3. **[作成]** を選択して、関数アプリをプロビジョニングし、デプロイします。

4. ポータルの右上隅の通知アイコンを選択し、"**デプロイが進行中**" であることを示す次のようなメッセージが表示されるまで待ちます。

![関数アプリのデプロイが進行中であることを示す通知](../media-draft/func-app-deploy-progress-small.PNG)

5. デプロイには時間がかかることがあります。 そのため、通知ハブを表示した状態で、"**デプロイに成功**" したことを示す次のようなメッセージが表示されるまで待ちます。

![関数アプリのデプロイが完了したことを示す通知](../media-draft/func-app-deploy-success-small.PNG)

6. お疲れさまでした。 関数アプリを作成し、デプロイしました。 **[リソースに移動]** を選択して、新しい関数アプリを確認します。

>[!TIP]
>目的の関数アプリがポータルに見つからない場合は、[ポータル内のお気に入りに Function App を追加する](https://docs.microsoft.com/azure/azure-functions/functions-how-to-use-azure-function-app-settings#favorite)方法を参照してください。

### <a name="create-a-function"></a>関数を作成する

関数アプリを用意できたので、ここでは関数を作成しましょう。 関数はトリガーによってアクティブ化されます。 このモジュールでは、HTTP トリガーを使用します。

1. 新しい関数アプリを展開し、関数のコレクションをポイントして、**[関数]** の横にある [追加] (**+**) ボタンを選択します。 この操作により関数作成プロセスが開始されます。 次のアニメーションで、この操作を示します。

![ユーザーが [関数] メニュー項目をポイントしたときにプラス記号が表示されるというアニメーション。](../media-draft/func-app-plus-hover-small.gif)

2. **[関数への早道]** ページで、**[WebHook + API]** を選択し、関数の言語を選択して、**[この関数を作成する]** をクリックします。

3. HTTP によってトリガーされる関数のテンプレートを使用して、選択した言語で関数が作成されます。 この演習では、JavaScript 関数を作成します。

### <a name="try-it-out"></a>試してみる

次の手順に従って、これまでに行った作業をテストしてみましょう。

1. 新しい関数で、右上の **[</> 関数の URL の取得]** をクリックし、**[既定値 (関数キー)]** を選択して、**[コピー]** をクリックします。

2. コピーした関数 URL をご利用のブラウザーのアドレス バーに貼り付けます。 この URL の末尾にクエリ文字列 `&name=<yourname>` を追加し、キーボードで `Enter` キーを押して要求を実行します。 次のような応答が関数によって返され、ブラウザーに表示されます。  

お疲れさまでした。 HTTP によってトリガーされる関数を関数アプリに追加し、想定どおりに動作することを確認するためにテストしました。

![関数の呼び出しが成功したことを示す応答メッセージのスクリーンショット。](../media-draft/default-http-trigger-response-small.PNG)

これまでの演習からわかるように、関数を作成するときはトリガーの種類を選択する必要があります。 各関数には、トリガーが 1 つだけあります。 この例では HTTP トリガーを使用しています。つまり、この関数は HTTP 要求を受信すると起動します。 次の JavaScript のスクリーンショットに示すように、既定の実装は、クエリ文字列または要求の本文で受信したパラメーター*名*の値を返します。 文字列が指定されていない場合、関数は呼び出し元のユーザーに対して、名前値を指定するよう求めるメッセージを返します。

![HTTP によってトリガーされる Azure 関数の既定の JavaScript 実装のスクリーンショット。](../media-draft/default-http-trigger-implementation-small.PNG)

このすべてのコードは、この関数のフォルダー内の *index.js* ファイルに格納されています。 では、関数のもう 1 つのファイルである *function.json* 構成ファイルを簡単に見てみましょう。 次の JSON の一覧に、この構成データが示されています。

```json
{
  "disabled": false,
  "bindings": [
    {
      "authLevel": "function",
      "type": "httpTrigger",
      "direction": "in",
      "name": "req"
    },
    {
      "type": "http",
      "direction": "out",
      "name": "res"
    }
  ]
}
```

ご覧のように、この関数には、`httpTrigger` 型の **req** という名前のトリガー バインディングと、`HTTP` 型の **res** という名前の出力バインディングが含まれています。 この関数の前述のコードでは、**req** パラメーターを使用して着信 HTTP 要求のペイロードにアクセスする方法を確認しました。 同様に、**res** パラメーターを設定するだけで HTTP 応答を送信しました。 このようにバインディングを使用すると、面倒な作業の一部が自動的に行われます。

>[!TIP]
>Azure portal で関数パネルの右側にある **[ファイルの表示]** メニューを展開すると、index.js と function.json を確認できます。  

### <a name="explore-binding-types"></a>バインディングの種類を確認する

1. 関数エントリの下には、次のスクリーンショットに示す一連のメニュー項目があります。

![[Function App] ブレードの関数の下にあるメニュー項目を示すスクリーンショット。](../media-draft/func-menu-small.PNG)

2. [統合] メニュー項目を選択して、関数の統合タブを開きます。 このユニットの手順に従うと、統合タブは次のスクリーンショットのようになるはずです。

![統合の UI またはタブを示すスクリーンショット。](../media-draft/func-integrate-tab-small.PNG)

このスクリーンショットに示すように、トリガー バインディングと出力バインディングを既に定義しています。 また、複数のトリガーを追加できないこともわかります。 実際、この関数のトリガーを変更するには、まずトリガーを削除してから、新しいトリガーを作成する必要があります。

一方、このフォームの **[入力]** セクションと **[出力]** セクションには、さらにバインディングを追加するためのプラス `+` 記号が表示されます。

3. **[入力]** 列の下にある **[+ 新しい入力]** を選択します。 次のスクリーンショットに示すように、入力バインディングとして考えられる全種類の一覧が表示されます。

![考えられる入力バインディングの一覧を示すスクリーンショット。](../media-draft/func-input-bindings-selector-small.PNG)

これらの各入力バインディングについて、およびそれらをソリューションでどのように使用できるかについて、よく検討してみましょう。 選択肢は多数あります。 弊社がサポートするデータ ソースは常に増えているので、このモジュールを読むときには、この一覧の情報が既に古くなっている可能性もあります。

4. **[キャンセル]** を選択してこの一覧を閉じます。

5. **[出力]** 列で **[+ 新しい出力]** を選択します。 次のスクリーンショットに示すように、出力バインディングとして考えられる全種類の一覧が表示されます。

![考えられる出力バインディングの一覧を示すスクリーンショット。](../media-draft/func-output-bindings-selector-small.PNG)

この場合も多数のオプションがあるため、スクリーンショットに示すように、右側のスクロール バーを使用する必要があります。

>[!TIP]
>サポートされているバインディングの詳細については、Azure Functions ドキュメント内の[サポートされるバインディングの一覧](https://docs.microsoft.com/azure/azure-functions/functions-versions)を参照してください。

ここまで、関数アプリを作成し、関数を追加する方法を学習しました。 HTTP 要求が行われると実行される、単純な関数の動作を見てきました。 また、ポータル UI、および関数に使用できる入力バインディングと出力バインディングの種類も確認しました。 次のユニットでは、入力バインディングを使用してデータベースからテキストを読み取ります。