この演習で作成するものの概要図を次に示します。

![HTTP 要求と HTTP 応答、およびそれぞれの req バインディング パラメーターと res バインディング パラメーターを示す、既定の HTTP トリガーの図](../media/3-default-http-trigger-visual-small.PNG)

HTTP 要求を受信したときに起動し、メッセージを送信して各要求に応答する関数を作成します。 パラメーター `req` と `res` は、それぞれトリガー バインディングと出力バインディングです。

[!include[](../../../includes/azure-sandbox-activate.md)]

## <a name="create-a-function-app"></a>関数アプリを作成する

このモジュール全体で使用する関数アプリを作成しましょう。 関数アプリを使用すると、リソースの管理、デプロイ、および共有を容易にするための論理ユニットとして関数をグループ化できます。

1. サンドボックスをアクティブ化したときと同じアカウントを使用して、[Azure portal](https://portal.azure.com/learn.docs.microsoft.com?azure-portal=true) にサインインします。

1. Azure portal の左上隅にある **[リソースの作成]** ボタンを選択し、**[コンピューティング]** > **[Function App]** を選択します。

1. 関数アプリのプロパティを次のように設定します。

    | プロパティ     | 推奨値  | 説明  |
    |--------------|------------------|--------------|
    | **アプリ名** | グローバルに一意の名前 | 新しい関数アプリを識別する名前。 有効な文字は、`a-z`、`0-9`、および `-` です。  |
    | **サブスクリプション** | ご利用のサブスクリプション | この新しい関数アプリが作成されるサブスクリプション。 |
    | **リソース グループ**|  **[既存のものを使用]** を選択し、_<rgn>[サンドボックス リソース グループ名]</rgn>_ を選びます。 | 関数アプリを作成するリソース グループの名前。 |
    | **OS** | Windows | 関数アプリをホストするオペレーティング システム。  |
    | **ホスティング プラン** |   従量課金プラン | Function App にどのようにリソースが割り当てられるかを定義するホスティング プラン。 既定の **[従量課金プラン]** では、関数での必要に応じてリソースが動的に追加されます。 このサーバーレス ホスティング モデルでは、関数が実行された時間にのみ課金されます。   |
    | **場所** | 一覧から選択する | 下の一覧の許可されている "*サンドボックス リージョン*" の中から、お客様に最も近いものを選択します。 |
    | **ランタイム スタック** | JavaScript | このモジュールのサンプル コードは、JavaScript で記述されています。  |
    | **ストレージ** |  グローバルに一意の名前 |  関数アプリによって使用される新しいストレージ アカウントの名前。 ストレージ アカウント名の長さは 3 - 24 文字で、数字と小文字のみを使用できます。 このダイアログ ボックスでは、アプリに指定した名前から派生した一意の名前がフィールドに入力されます。 ただし、別の名前や既存のアカウントを自由に使用できます。 |

    ### <a name="sandbox-regions"></a>サンドボックス リージョン
    [!include[](../../../includes/azure-sandbox-regions-first-mention-note-friendly.md)]

1. **[作成]** を選択して、関数アプリをプロビジョニングし、デプロイします。

1. ポータルの右上隅の通知アイコンを選択し、"**デプロイが進行中**" であることを示す次のようなメッセージが表示されるまで待ちます。

    ![関数アプリのデプロイが進行中であることを示す通知](../media/3-func-app-deploy-progress-small.PNG)

1. デプロイには時間がかかることがあります。 そのため、通知ハブを表示した状態で、"**デプロイに成功**" したことを示す次のようなメッセージが表示されるまで待ちます。

    ![関数アプリのデプロイが完了したことを示す通知](../media/3-func-app-deploy-success-small.PNG)

 1. 関数アプリがデプロイされたら、ポータルの **[すべてのリソース]** に移動します。 関数アプリは、タイプ **[App Service]** にリストされ、指定した名前になります。 リストから関数アプリを選択して開きます。

    >[!TIP]
    >ポータルで目的の関数アプリが見つからない場合は、[ポータルでお気に入りに関数アプリを追加する](https://docs.microsoft.com/azure/azure-functions/functions-how-to-use-azure-function-app-settings#favorite)方法を参照してください。

## <a name="create-a-function"></a>関数を作成する

関数アプリを用意できたので、ここでは関数を作成しましょう。 関数はトリガーによってアクティブ化されます。 このモジュールでは、HTTP トリガーを使用します。

<!-- Start temporary fix for issue #2498. -->
> [!IMPORTANT]
> 現時点では、このモジュールの演習は Azure Functions V1 を使用して行います。 以下の手順に慎重に従って、関数アプリで V1 ランタイム バージョンが使用されていることを確認してください。 

1. **[Function Apps]** リストで、関数アプリを選択します。
1. **[プラットフォーム機能]** を選択します。
1. **[プラットフォーム機能]** 画面の **[全般設定]** で、**[Function App の設定]** を選択します。
1. **[ランタイム バージョン]** で *[~1]* を選択します。
1. **[Function App の設定]** を閉じます。

これで、Azure Functions V1 ランタイムを使用するように関数アプリが構成されました。 最初の関数の作成を続行できます。
<!-- End temporary fix for issue #2498. --> 
1. **[関数]** の横にある [追加] (**+**) ボタンを選択します。 この操作により関数作成プロセスが開始されます。 

1. **[すぐに使用を開始する]** ページで、**[関数を独自に作成する]** セクションの **[カスタム関数]** を選択します。

1. これにより、すべてのテンプレートが一覧表示されます。一覧から **[HTTP トリガー]** テンプレートを選択します。

1. **[新しい関数]** ブレードで、必要に応じて名前を変更し、**[認証レベル]** を _[関数]_ にして **[作成]** をクリックします。

1. 新しい関数で、右上の **[</> 関数の URL の取得]** リンクをクリックし、**[既定値 (関数キー)]** を選択して、**[コピー]** を選択します。

1. コピーした関数 URL をブラウザーの新しいタブのアドレス バーに貼り付けます。

1. この URL の末尾にクエリ文字列値 `&name=Azure` を追加し、キーボードの Enter キーを押して要求を実行します。 関数から次のような応答が返され、ブラウザーに表示されます。

    ```output
    <string xmlns="http://schemas.microsoft.com/2003/10/Serialization/">Hello Azure</string>
    ```

これまでの演習からわかるように、関数を作成するときはトリガーの種類を選択する必要があります。 各関数には、トリガーが 1 つだけあります。 この例では、HTTP トリガーを使用しています。つまり、この関数は HTTP 要求を受信すると起動します。 次の JavaScript のスクリーンショットに示す既定の実装では、クエリ文字列または要求の本文で受信したパラメーター*名*の値で応答します。 文字列が指定されていない場合、関数は呼び出し元に対して名前値を指定するよう求めるメッセージで応答します。

![HTTP によってトリガーされる Azure 関数の既定の JavaScript 実装](../media/3-default-http-trigger-implementation-small.PNG)

このコードはすべて、この関数のフォルダー内の **index.js** ファイルにあります。 では、関数のもう 1 つのファイルである **function.json** 構成ファイルを簡単に見てみましょう。 次の JSON の一覧に、この構成データが示されています。

```json
{
  "disabled": false,
  "bindings": [
    {
      "authLevel": "function",
      "type": "httpTrigger",
      "direction": "in",
      "name": "req"
    },
    {
      "type": "http",
      "direction": "out",
      "name": "res"
    }
  ]
}
```

ご覧のように、この関数には、`httpTrigger` 型の **req** という名前のトリガー バインディングと、`HTTP` 型の **res** という名前の出力バインディングが含まれています。 この関数の前述のコードでは、**req** パラメーターを使用して着信 HTTP 要求のペイロードにアクセスする方法を確認しました。 同様に、**res** パラメーターを設定するだけで HTTP 応答を送信しました。 このようにバインディングを使用すると、面倒な作業の一部が自動的に行われます。

>[!TIP]
>Azure portal で関数パネルの右側にある **[ファイルの表示]** メニューを展開すると、**index.js** ファイルと **function.json** ファイルを確認できます。

### <a name="explore-binding-types"></a>バインディングの種類を確認する

1. 関数エントリの下には、次のスクリーンショットに示す一連のメニュー項目があります。

    ![[Function App] ブレードの関数の下にあるメニュー項目を示すスクリーンショット。](../media/3-func-menu-small.PNG)

1. [統合] メニュー項目を選択して、関数の統合タブを開きます。 このユニットの手順に従うと、統合タブは次のスクリーンショットのようになるはずです。

    ![統合の UI またはタブを示すスクリーンショット。](../media/3-func-integrate-tab-small.PNG)

    > [!NOTE]
    > スクリーンショットに示すように、トリガー バインディングと出力バインディングを既に定義しています。 また、"_複数の_" トリガーを追加できないこともわかります。 実際に、この関数のトリガーを変更するには、まずトリガーを削除してから、新しいトリガーを作成する必要があります。 ただし、この UI の **[入力]** セクションと **[出力]** セクションには、複数の入力値を受け入れ、複数の出力値を出力できるように、バインディングを追加するためのプラス記号 (+) が表示されます。

1. **[入力]** 列の **[+ 新しい入力]** を選択します。 次のスクリーンショットに示すように、入力バインディングとして考えられる全種類の一覧が表示されます。

    ![考えられる入力バインディングの一覧を示すスクリーンショット。](../media/3-func-input-bindings-selector-small.PNG)

   これらの各入力バインディングについて、およびそれらをソリューションでどのように使用できるかについて、よく検討してみましょう。 選択肢は多数あります。 サポートされるデータ ソースは常に増えているので、このモジュールを読むときまでに、この一覧が変更されている可能性もあります。

1. このモジュールの後半で入力バインディングの追加に戻りますが、ここでは **[キャンセル]** を選択してこの一覧を閉じます。

1. **[出力]** 列で **[+ 新しい出力]** を選択します。 次のスクリーンショットに示すように、使用可能な出力バインディングの全種類の一覧が表示されます。

    ![使用可能な出力バインディングの一覧を示すスクリーンショット。](../media/3-func-output-bindings-selector-small.PNG)

   ご覧のように、使用できる出力バインディングの種類が複数あります。 このモジュールの後半で出力バインディングの追加に戻りますが、ここでは **[キャンセル]** を選択してこの一覧を閉じます。

ここまで、関数アプリを作成し、関数を追加する方法を学習しました。 HTTP 要求が行われたときに実行される単純な関数の実際の動作を確認しました。 また、Azure portal UI、および関数で使用できる入力バインディングと出力バインディングの種類も確認しました。 次のユニットでは、入力バインディングを使用してデータベースからテキストを読み取ります。