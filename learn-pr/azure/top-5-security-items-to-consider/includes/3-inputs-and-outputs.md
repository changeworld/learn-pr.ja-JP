今日のアプリケーションで最もよく見られるセキュリティ上の弱点は､外部ソースから受信した入力､特に_ユーザー入力_を正しく処理しないことです｡ どのような入力であれ、必ず詳細に調べて、使用する前に必ず妥当であることを検証するようにしてください。 これを怠ると、データの損失や露出、特権の昇格、さらには他のユーザーのコンピューター上で悪意のあるコードが実行されてしまうことにさえなり得ます。

悲劇的なことは、この問題は解決が容易であるということです。 ここでは､受信時､画面への表示時､または保存時のデータの処理方法を取り上げます｡

## <a name="why-do-we-need-to-validate-our-input"></a>なぜ私たちは入力を検証する必要があるのでしょうか。

Web サイトでアカウントを作成できるようにするインターフェイスを構築しているときのことを考えてみてください。 プロファイル データには、サイトにアクセスするユーザーの誰にも表示する名前、電子メール、ニックネームが含まれます。 新しいユーザーがプロファイルを作成し、SQL コマンドを含むニックネームを入力したら､どうでしょう｡ 例えば､不正なユーザーが次のように入力したら｡

```sql
Eve'); DROP TABLE Users;--
```

この値がデータベースに挿入すると､絶対に実行したくないコマンドを実行するように SQL ステートメントが改変される可能性があります。 これは、「SQL インジェクション」攻撃と呼ばれ､正しく入力を処理しなかったときに発生する可能性がある_数多くある_悪用の 1つです｡ この問題を解決するためには、何をすればよいのでしょうか。 このユニットでは、(上述の悪用を解決する) 入力を検証するタイミングと出力のエンコード方法、パラメーター化クエリを作成する方法を学びます。 アプリケーションに入力される悪意のある入力に対する防御手法は大きく 3 つあります。

## <a name="when-do-i-need-to-validate-input"></a>いつ入力を検証すればよいのでしょうか｡

答えは_常に_です｡ アプリケーションに対する**あらゆる**入力を検証する必要があります。 これには、URLのパラメータ､ユーザーからの入力､データベースからのデータ、API からのデータ､その他､ユーザーが操作できる可能性があるクリアーな形式で渡されるあらゆるものが含まれます｡ 必ずブラックリストではなく､ホワイトリスト方式を採用してください｡このことは､｢問題がないことが既知｣の入力だけを受け付けることを意味します｡ブラックリスト方式では､不正な入力だけに注目することになり､危険性がある入力を完全に網羅することこは不可能なためです｡  この防御策が回避できないよう､この作業はクライアント側ではなく､サーバー側で行ってください (両方で行ってもよい)｡ **あらゆる**データを信頼できないデータとみなしてください｡そうすることで､Web アプリでよくある脆弱性の大半から身を守ることができます｡

ASP.NET を使用している場合、そのフレームワークには､クライアントとサーバーの双方で[入力を検証するための優れたサポート](https://docs.microsoft.com/aspnet/web-pages/overview/ui-layouts-and-themes/validating-user-input-in-aspnet-web-pages-sites)が用意されています｡

別の Web フレームワークを使用している場合は、[OWASP Input Validation Cheatsheet](https://www.owasp.org/index.php/Input_Validation_Cheat_Sheet)に入力を検証するために素晴らしいテクニックがいくつか用意されています｡


## <a name="always-use-parameterized-queries"></a>常にパラメーター化クエリを利用する

SQL データベースは、一般に、プロファイル情報などのデータを保存するために使用されます。  コードにオンザフライでインライン SQL やその他データベース クエリを作成して、そのままデータベースに送信しないでください。既に説明したように、これは惨事を招く行為です。

たとえば、**以下を行わないでください** (インライン SQL と呼ばれる)。

```csharp
string userName = ... // receive input from the user BEWARE!
...
string query = "SELECT *  FROM  [dbo].[users] WHERE userName = '" + userName + "'";
```

ここでは、テキスト文字列を連結して、クエリを作成しています。ユーザーから入力を受け取り、ユーザーを検索する動的な SQL クエリを生成します。 ここでも、悪意のあるユーザーがこれを行っていることに気付いた場合、あるいは脆弱性があるかどうかを見るためにいくつかの入力を_試し_ただけでも、重大な障害が生じる場合があります。 代わりに、次などの、パラメーター化 SQL ステートメントやストアド プロシージャを利用します。

```sql
-- Lookup a user
CREATE PROCEDURE sp_findUser
(
@UserName varchar(50)
)

SELECT *  FROM  [dbo].[users] WHERE userName = @UserName
```

このメソッドでは、コードからそのプロシージャを安全に呼び出し、SQL ステートメントの一部として扱われることを心配せずに `userName` の文字列を渡すことができます。

## <a name="always-encode-your-output"></a>必ず出力をエンコードする

ビジュアルに、またはドキュメントのいずれかに出力を行う場合、必ずエンコードして、エスケープされる必要があります。 これにより、サニタイズの過程で何かが失われても身を守ることができます。さもないと、悪用される恐れがあるコードが誤って生成されてしまいます。 そうすることで､あらゆるものが_出力_として表示され､実行すべきものとして解釈されることがなくなります｡ これは、もう 1 つの非常に一般的な攻撃方法で "クロス サイト スクリプティング" (XSS) と呼ばれます。

これは非常に一般的な要件であるため、ユーザーに代わって ASP.NET で実行されるもう 1 つの領域です。 既定では、すべての出力が既にエンコードされています。 別の Web フレームワークを使用している場合は、[OWASP XSS Prevention Cheatsheet](https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet) で Web サイトでの出力エンコードに関するオプションを確認できます。

## <a name="summary"></a>まとめ

入力のサニタイジングと検証は、入力が確実に有効であり、安全に使用、保存できるようにするための必須要件です。 最新の Web フレームワークのほとんどには、この作業の一部を自動化する機能が組み込まれています。 お好みのフレームワークで提供されている機能については、そのドキュメントを確認してください。 これが一番よく起こる場所は Web アプリケーションですが、他の種類のアプリケーションも同様に脆弱であることを念頭に置いておいてください。 ご使用の新しいアプリケーションがデスクトップ アプリであるからといって、ご自分が安全であるとは考えないでください。 アプリを使用してデータが破壊されたり、会社の評判が落とされたりすることのないよう、いつでもユーザー入力を適切に処理する必要があります。