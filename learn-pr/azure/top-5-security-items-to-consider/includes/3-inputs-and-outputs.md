アプリケーションの最も一般的なセキュリティ上の弱点が今日は特に、外部ソースから受信した入力を処理しない_ユーザー入力_します。 使用される前に検証されたかどうかを確認する任意の入力をよく見るを反映する必要があります。 失敗すると、データの損失または危険度の特権のエスカレーションまたは他のユーザーのコンピューターで悪意のあるコードの実行が偶数で発生することができます。

簡単な問題を解決するためには、このことは、安全なのです。 ここではデータを処理する方法をについて説明しますそれを受信したとき、後で使用できる格納されるときの画面が表示されたら、それとします。

## <a name="why-do-we-need-to-validate-our-input"></a>理由の入力を検証する必要があるのでしょうか。

Web サイトでアカウントを作成できるようにするインターフェイスを作成することを想像してください。 プロファイル データには、名前、電子メール、およびサイトにアクセスするすべてのユーザーを表示するニックネームが含まれています。 場合、新しいユーザー プロファイルを作成し、いくつかの SQL コマンドを含むニックネームを入力しますか。 例の場合、不正なユーザーが入力ようなもの。

```output
Eve'); DROP TABLE Users;--
```

データベースにこの値をやみくもに挿入する場合は絶対に実行したくないコマンドを実行する SQL ステートメントを変更ことでした可能性があります。 これは、「SQL インジェクション」攻撃と呼ばれますとの 1 つです、_多く_種類攻撃種類入力を正しく処理されない場合に可能性のある実行できます。 そのため、どのように処理できるでしょうこれを解決するには このユニットは、(が上記の脆弱性を解決) クエリを実行すると、入力、出力をエンコードする方法、および作成する方法を検証するパラメーター化されたときに指導されます。 これらは、アプリケーションに入力されている悪意のある入力に対する次の 3 つの主な防御手法です。

## <a name="when-do-i-need-to-validate-input"></a>ときに入力を検証する必要があるのでしょうか。

その答えは_常に_します。 検証する必要があります**すべて**アプリケーションについて入力します。 これには、ユーザー、データベースからのデータ、および API からユーザーの操作可能性のある可能性がありますをクリア テキストで渡されるデータからの入力を URL にはパラメーターが含まれます。 常に危険性のある入力の完全な一覧と考えることはできませんのでのみ (具体的には参照場所の入力が不適切な) ブラック リストではなく、「正常」の入力に同意したことを意味、ホワイト リストのアプローチを使用します。  サーバー、クライアント側いない (またはクライアント側だけでなく) は、この作業を行う、防御することを確認するを回避することはできません。 扱う**すべて**として信頼されていないデータはから保護するほとんどの一般的な web アプリの脆弱性。

ASP.NET を使用している場合に、フレームワークが提供[入力を検証するための優れたサポート](https://docs.microsoft.com/aspnet/web-pages/overview/ui-layouts-and-themes/validating-user-input-in-aspnet-web-pages-sites)クライアントとサーバーの両方の側でします。

別の web フレームワークを使用している場合は、いくつかの優れた手法で使用できる入力の検証を行うための[OWASP 入力検証チートシート](https://www.owasp.org/index.php/Input_Validation_Cheat_Sheet)します。


## <a name="always-use-parameterized-queries"></a>常にパラメーター化クエリを使用して、

SQL データベースは、プロファイル情報などのデータの保存によく使用されます。  インラインを作成しないでください、災害のレシピは、上記のとおりこれは、SQL またはその他のコードで"その場"でクエリをデータベースしデータベースに直接送信します。

たとえば、**これを行わない**(インライン SQL と呼ばれます)。

```csharp
string userName = ... // receive input from the user BEWARE!
...
string query = "SELECT *  FROM  [dbo].[users] WHERE userName = '" + userName + "'";
```

ここで、クエリを作成するためのテキスト文字列を連結しました、ユーザーから入力を取得し、ユーザーを検索する動的な SQL クエリを生成します。 ここでも、悪意のあるユーザーが実現しましたが、これを行うまたはだけ_しようとした_別の入力スタイルの重大な障害で終わる可能性、脆弱性があった場合を参照してください。 代わりに、パラメーター化された SQL ステートメントまたはストアド プロシージャなど、これを使用します。

```sql
-- Lookup a user
CREATE PROCEDURE sp_findUser
(
@UserName varchar(50)
)

SELECT *  FROM  [dbo].[users] WHERE userName = @UserName
```

このメソッドを使用することができますプロシージャを呼び出す、コードから安全に渡す、 `userName` SQL ステートメントの一部として扱われることを心配せずに文字列。

## <a name="always-encode-your-output"></a>常に、出力をエンコードします。

視覚的にまたはドキュメント内のいずれかを表示する出力をエンコードされた常とエスケープする必要があります。 サニタイズのパスで何かが実行されなかったか、コードを誤って生成悪用される可能性がある場合をこの保護できます。 これにより、すべてのものとして表示されることを確認して_出力_誤って実行する必要があるものとして解釈します。 これは、「クロス サイト スクリプティング」(XSS) と呼ばれる別の一般的な攻撃方法です。

これなどの一般的な要件であるためこれは、ASP.NET の作業を実行する、別の領域です。 既定では、[エンコードされているすべての出力](https://docs.microsoft.com/aspnet/core/security/cross-site-scripting?view=aspnetcore-2.1)します。 別の web フレームワークを使用している場合は、出力を使用した web サイトでエンコードするためのオプションを確認できます、 [OWASP XSS 防止チートシート](https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet)します。

## <a name="summary"></a>まとめ

Santizing と、入力の検証は、入力内容が有効で安全に使用し、格納することを確認するために必要な要件です。 ほとんどの最新の web フレームワークでは、この作業の一部を自動化できますが、組み込みの機能を提供します。 優先、フレームワークのドキュメントを確認でき、プラン機能を参照してください。 Web アプリケーションでは、このような最も一般的な場所ですは、単に脆弱性のある他の種類のアプリケーションであることに留意してください。 新しいアプリケーションがデスクトップ アプリのためだけに安全だと思います。 ユーザーが、アプリを使用して、データが破損または企業の評判を破損しないことを確認するユーザー入力を適切に処理する必要があります。