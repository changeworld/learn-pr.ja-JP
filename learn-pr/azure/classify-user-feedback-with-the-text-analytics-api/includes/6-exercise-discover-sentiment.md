Text Analytics API サービスを呼び出してセンチメント スコアを返すように関数の実装を更新しましょう。

1. Function App ポータルで目的の関数 ([!INCLUDE [func-name-discover](./func-name-discover.md)]) を選択します。

1. 画面の右側にある **[ファイルの表示]** メニューを展開します。

1. **[ファイルの表示]** タブで **[index.js]** を選択し、エディターでコード ファイルを開きます。

1. コード ファイルの内容全体を次の JavaScript に置き換えます。

[!code-javascript[](../code/discover-sentiment-sort.js?highlight=7)]

このコードで何が起こっているかを見てみましょう。

- テキスト分析サービスを呼び出すには、コード スニペットで強調表示されている `accessKey` に、以前に保存しておいたキーを設定します。
- `uri` を、アクセス キーを取得したリージョンに更新します (そのリージョンが、この例で示されている *westus* ではない場合)。
- コード ファイルの末尾に、`documents` 配列を定義してあります。 この配列は、Text Analytics サービスに送信するペイロードです。 
- ここでは、`documents` 配列には単一のエントリがあります。これは、関数をトリガーしたキュー メッセージです。 この配列内には 1 つのドキュメントしかありませんが、ソリューションが一度に 1 つのメッセージしか処理できないわけではありません。 Azure Functions ランタイムは、関数のいくつかのインスタンスを "*並列*" で呼び出して、メッセージを一括して取得および処理します。 現在、既定のバッチ サイズは 16 で、最大バッチ サイズは 32 です。
- `id` は、配列内で一意である必要があります。 `language` プロパティは、ドキュメント テキストの言語を指定するものです。  
- 次に、`get_sentiments` メソッドを呼び出します。このメソッドは、HTTPS モジュールを使用して、Text Analytics API を呼び出します。 各要求のヘッダーで、サブスクリプションまたはアクセス キーを渡している点に注意してください。
- サービスが終了するときに、`response_handler` が呼び出され、コンソールへの応答が `context.log` を使用してログに記録されます 

## <a name="try-it-out"></a>試してみる

キューへの分類を見る前に、テスト実行用にどのようなものがあるかを確認しておきましょう。 

1.  Function App ポータルで関数 [!INCLUDE [func-name-discover](./func-name-discover.md)] を選択した状態で、左端にある [テスト] メニュー項目をクリックして展開します。

2. **[テスト]** メニュー項目を選択し、テスト パネルが開いていることを確認します。 次のスクリーンショットは、どのような表示になるかを示しています。 

![展開された関数のテスト パネルを示すスクリーン ショット。](../media-draft/test-panel-open-small.png)

3. スクリーンショットに示すように、要求本文にテキストの文字列を追加します。 

1.  テスト パネルの下部にある **[実行]** をクリックします。

1. メイン画面の左下のコード エディターの下で、**[ログ]** タブが展開されていることを確認します。 

1. **[ログ]** タブで、関数が完了したというログ情報が表示されていることを確認します。 ウィンドウには、Text Analytics API 呼び出しからの応答も表示されます。 

![テスト パネルと成功したテストの結果を示すスクリーンショット。](../media-draft/sentiment-response-log1.png)

うまくいきました。 [!INCLUDE [func-name-discover](./func-name-discover.md)] は、設計どおりに動作します。 この例では、非常に明るいメッセージを渡し、0.98 を超えるスコアを受け取りました。 それよりも明るくないメッセージに変更し、テストを再実行して、応答に注意してみてください。

## <a name="try-it-out-again-optional"></a>もう一度試してみる (省略可能)

テストを繰り返してみましょう。 今回は、ポータルのテスト ウィンドウを使用する代わりに、実際に入力キューにメッセージを入れて、何が起きるかを監視します。 

1. ポータルの **[リソース グループ]** セクションで、該当するリソース グループに移動します。

1. このレッスンで使用したリソース グループを選択します。

1. 表示された **[リソース グループ]** パネルで、[ストレージ アカウント] エントリを探して選択します。

![スクリーンショット ([リソース グループ] ウィンドウでストレージ アカウントを選択したところ)。](../media-draft/select-storage-account.png)

1. [ストレージ アカウント] メイン ウィンドウの左側のメニューから **[ストレージ エクスプローラー (プレビュー)]** を選択します。  この操作により、ポータル内で Azure Storage Explorer が開きます。 この段階では、画面は次のスクリーンショットのようになります。 

![ストレージ アカウントが示されているストレージ エクスプローラーのスクリーンショット (現時点でキューはなし)。](../media-draft/sa-no-queue.png)

ご覧のとおり、このストレージ アカウントにはまだキューがないので、修正しましょう。

1. このレッスンの前の方で、トリガーに関連付けられているキューに **new-feedback-q** という名前を付けました。 ストレージ エクスプローラーで **[キュー]** 項目を右クリックし、*[キューの作成]* を選択します。

1. 開かれたダイアログ ボックスで「**new-feedback-q**」と入力し、**[OK]** をクリックします。 これで、入力キューができました。 

1. 左側のメニューで新しいキューを選択して、このキューのデータ エクスプローラーを表示します。 当然、キューは空です。 ウィンドウ上部にある **[メッセージの追加]** コマンドを使って、キューにメッセージを追加してみましょう。

1. **[メッセージの追加]** ダイアログ ボックスの **[メッセージ テキスト]** フィールドに「This message came from our input queue, new-feedback-q」 (このメッセージは入力キューの new-feedback-q からのものです) と入力し、ダイアログの下部の **[OK]** をクリックします。 

1. データ エクスプローラーで、次のスクリーンショットのようなメッセージを確認します。
![ストレージ アカウントが示されているストレージ エクスプローラーのスクリーンショット (作成したメッセージがキューにある状態)。](../media-draft/message-in-input-queue.png)

1. 数秒後、**[最新の情報に更新]** をクリックして、キューのビューを最新の情報に更新します。 キューが空であるかどうかをもう一度確認します。 何かがキューからメッセージを読み取ったはずです。 

1. ポータルで関数に戻り、**[モニター]** タブを開きます。一覧で最新のメッセージを選択します。 new-feedback-q に投稿したキュー メッセージが関数によって処理されたことを確認します。

![new-feedback-q に投稿したキュー メッセージが関数によって処理されたことを示すエントリが表示されている [モニター] ダッシュボードのスクリーンショット。](../media-draft/message-in-monitor.png)

このテストでは、キューに何かを追加した後で関数によってそれが処理されるのを確認する、完全なラウンドトリップを行いました。

ソリューションは着実に進歩しています。 関数が有益なことを実行できるようになりました。 入力キューからテキストを受け取り、Text Analytics API サービスを呼び出してセンチメント スコアを取得しています。  また、Azure portal と Storage Explorer を通じて関数をテストする方法も学習しました。 次の演習では、出力バインディングを使用したキューへの書き込みがいかに簡単であるかを見ていきます。