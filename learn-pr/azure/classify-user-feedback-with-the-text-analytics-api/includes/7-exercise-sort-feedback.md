すべての関数には、トリガー バインドが 1 つだけ備わっています。 これは、コードの実行をどのようにして引き起こすかを定義するものです。 トリガーに加え、データ ソースへの接続手段となるバインドを定義することができます。 既出のソリューション図で、3 つのキューにメッセージを送信したいと思います。 それらの接続を出力バインドとして関数に定義することになります。 これらのバインドは、**[出力バインディング]** という UI で作成することができます。 ただしここでは、時間を節約するために構成ファイルを直接編集します。

1. Function App ポータルで目的の関数 ([!INCLUDE [func-name-discover](./func-name-discover.md)]) を選択します。

1. 画面の右側にある **[ファイルの表示]** メニューを展開します。

1. **[ファイルの表示]** タブで **[function.json]** を選択し、エディターで構成ファイルを開きます。

1. 構成ファイルの内容全体を次の JSON に置き換えます。 

[!code-json[](../code/function.json)]

この構成には、新しいバインドを 3 つ追加しています。

- 新しいバインドの種類は、いずれも `queue` です。 フィードバックのセンチメントが明らかになった後、3 つのキューにフィードバック メッセージが追加されます。これらのバインドは、それらのキューに使用するものです。
- メッセージはこれらのキューに対してポストされるため、各バインドの方向は `out` として定義します。
- それぞれのバインドには、同じストレージ アカウント接続を使用します。
- 各バインドには、一意の `queueName` と `name` があります。

キューには、簡単にメッセージを追加できます (例: `context.bindings.negativeFeedbackQueueItem = "<message>"`)。

## <a name="update-implementation-to-sort-feedback-into-queues-based-on-sentiment-score"></a>センチメント スコアに基づいてフィードバックを各キューに分類するよう実装を更新する

フィードバック ソーターの目的は、ポジティブ、ニュートラル、ネガティブの 3 つのバケットにフィードバックを分類することです。 ここまでで、入力キューを追加し、Text Analytics API を呼び出すコードを追加して、出力キューを定義しました。 このセクションでは、センチメントに基づいてメッセージを各キューに移動するロジックを追加します。

1. 目的の関数 ([!INCLUDE [func-name-discover](./func-name-discover.md)]) に移動し、もう一度コード エディターで `index.js` を開きます。

1. この実装を次のように置き換えます。
[!code-javascript[](../code/discover-sentiment+sort.js?highlight=25-48)]

強調表示されているのは、既存の実装に追加したコードです。 このコードによって、Text Analytics API コグニティブ サービスからの応答が解析されます。 メッセージは、センチメント スコアに基づき、3 つの出力キューのいずれかに転送されます。 メッセージをポストするコードでは単に、適切なバインド パラメーターを設定しています。

## <a name="try-it-out"></a>試してみる

更新後の実装をテストするために、Storage Explorer に戻りましょう。 

1. ポータルの **[リソース グループ]** セクションで、該当するリソース グループに移動します。

1. このレッスンで使用したリソース グループを選択します。

1. 開いた **[リソース グループ]** パネルで、[ストレージ アカウント] エントリを探して選択します。
![スクリーンショット ([リソース グループ] ウィンドウでストレージ アカウントを選択したところ)。](../media-draft/select-storage-account.png)

1. [ストレージ アカウント] メイン ウィンドウの左側のメニューから **[ストレージ エクスプローラー (プレビュー)]** を選択します。  この操作により、ポータル内で Azure Storage Explorer が開きます。 この段階では、画面は次のスクリーンショットのようになります。
![ストレージ アカウントを表示する Storage Explorer のスクリーンショット (現時点でキューは 1 つ)。](../media-draft/storage-explorer-menu-inputq.png)

**[キュー]** コレクションにキューが 1 つ表示されています。 このモジュールの前出のテスト セクションで定義した入力キュー [!INCLUDE [input-q](./q-name-input.md)] です。

1. 左側のメニューから [!INCLUDE [input-q](./q-name-input.md)] を選択して、このキューのデータ エクスプローラーを表示します。 当然、キューにデータはありません。 ウィンドウ上部にある **[メッセージの追加]** コマンドを使って、キューにメッセージを追加してみましょう。 

1. **[メッセージの追加]** ダイアログの  **[メッセージ テキスト]** フィールドに「I'm having fun with this exercise!」と入力し、ダイアログの一番下にある **[OK]** をクリックします。 

1. [!INCLUDE [input-q](./q-name-input.md)] のデータ ウィンドウにメッセージが表示されます。 数秒後、データ ビューの一番上にある **[最新の情報に更新]** をクリックして、キューのビューを最新の情報に更新します。 しばらくしてメッセージが消えるようすを観察してください。 どこに行ってしまったのでしょうか。

1. 左側のメニューの **[キュー]** コレクションを右クリックします。 "*新しい*" キューが出現していることがわかります。
![Storage Explorer のスクリーンショット。コレクションに新しいキューが作成されている。 キューにはメッセージが 1 つ存在している。](../media-draft/sa-new-output-q.png)

キュー [!INCLUDE [positive-q](./q-name-positive.md)] は、初めてメッセージがポストされたときに自動的に作成されたものです。 Azure Functions のキュー出力バインドでは、ポスト先となる出力キューを事前に手動で作成する必要はありません。 受信メッセージが関数によって [!INCLUDE [positive-q](./q-name-positive.md)] に分類されていることを確認したら、次のメッセージがどこに到達するかを見てみましょう。

5. 上記と同じ手順を使って次のメッセージを [!INCLUDE [input-q](./q-name-input.md)] に追加します。

- "I like broccoli!"
- "Microsoft is a company"

6. [!INCLUDE [input-q](./q-name-input.md)] が再び空になるまで **[最新の情報に更新]** をクリックします。 このプロセスには少し時間がかかる場合があります。何度か更新ボタンを押さなければならないこともあります。

1. **[キュー]** コレクションを右クリックすると、さらに 2 つのキューが出現していることがわかります。 キューの名前はそれぞれ [!INCLUDE [neutral-q](./q-name-neutral.md)] と [!INCLUDE [negative-q](./q-name-negative.md)] です。 これには数秒かかる場合があるので、新しいキューが表示されるまで、**[キュー]** コレクションの更新操作を繰り返してください。 完了すると、キューの一覧が次のように表示されます。

![[キュー] コレクションに 4 つのキューを表示する Storage Explorer メニューのスクリーンショット。](../media-draft/sa-final-q-list.png)

一覧に表示されている各キューをクリックして、メッセージが存在するかどうかを確認します。 先ほど示したメッセージを追加した場合、[!INCLUDE [positive-q](./q-name-positive.md)]、[!INCLUDE [neutral-q](./q-name-neutral.md)]、[!INCLUDE [negative-q](./q-name-negative.md)] にそれぞれ 1 つメッセージが表示されます。

うまくいきました。 これで正常に機能するフィードバック ソーターが完成しました。 入力キューにメッセージが到着すると、関数が Text Analytics API サービスを使ってセンチメント スコアを取得します。 そのスコアに基づいて、メッセージが適切なキューに転送されます。 この関数は 1 度に 1 つのキュー アイテムしか処理できないように見えますが、実際には、Azure Functions Runtime は複数のキュー アイテムを一括で読み取り、さらに関数のインスタンスを追加で生成することによって、それらのアイテムを並列に処理します。 